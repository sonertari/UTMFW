$ComixWall: patch-p3scan_c,v 1.6 2016/07/12 10:30:10 soner Exp $
--- p3scan.c.orig	Tue Aug  1 15:40:42 2017
+++ p3scan.c	Thu Aug  3 22:45:20 2017
@@ -44,33 +44,36 @@ TODO: Wanted: no iptables support
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <sys/socket.h>
+#include <signal.h>
+#include <assert.h>
 #include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include <sys/time.h>
+#include <sys/param.h>
+#include <sys/signal.h>
 #include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <net/pfvar.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <stdarg.h>
-#include <sys/signal.h>
-#include <sys/wait.h>
 #include <pwd.h>
 #include <time.h>
-#include <sys/time.h>
 #include <syslog.h>
-#include <sys/param.h>
 #include <ctype.h>
-#include <linux/netfilter_ipv4.h>
-#include <malloc.h>
 #include <getopt.h>
 #include <netdb.h>
 #include <libgen.h>
 #include <errno.h>
 #include <dirent.h>
-#include <sys/statvfs.h>
-#include <assert.h>
-#include <sys/select.h>
+#include <sys/ucred.h>
+#include <sys/mount.h>
 
 #include "p3scan.h"
 #include "getline_ssl.h"
@@ -105,6 +108,13 @@ extern int filecount;
 extern int MIMEH_set_outputdir(char *);
 #endif
 
+u_int32_t read_address(const char *s)
+{
+	int a, b, c, d;
+	sscanf(s, "%i.%i.%i.%i", &a, &b, &c, &d);
+	return htonl(a << 24 | b << 16 | c << 8 | d);
+}
+
 static int sockfd; /* has to be global, do_sigterm_main() want's to close them */
 
 /* the proxycontext is global for do_sigterm_proxy().
@@ -152,7 +162,7 @@ void do_log(int level, const char *fmt,...){
    if (!config->debug && config->quiet && level==LOG_NOTICE) return;
    va_start(az,fmt);
    vsnprintf(puffer, 4000, fmt, az);
-   strcpy(timenow,ctime(&now)+ 11);
+   strlcpy(timenow,ctime(&now)+ 11, sizeof(timenow));
    if (!config->debug){
      openlog(config->syslogname, LOGOPT, LOGFAC);
      syslog(LOG_NOTICE, "%s\n", puffer);
@@ -401,7 +411,7 @@ char *right(char *string, size_t i){
 
    if (i > strlength) i = strlength;
    buf = stralloc(i);
-   strcpy(buf, &string[strlength-i]);
+   strlcpy(buf, &string[strlength-i], i);
    return buf;
 }
 
@@ -699,7 +709,7 @@ int scan_mailfile(struct proxycontext *p){
 #define COPYMSG "/var/spool/p3scan/copymsg "
    FILE * scanner;
    static char  line[4096*16];
-   struct statvfs fs;
+   struct statfs fs;
    int htmlfd=0;
 
    ret=checktimeout(p);
@@ -720,7 +730,7 @@ int scan_mailfile(struct proxycontext *p){
    what the user determines is enough room in p3scan.conf
    This was already done... but it is also dynamic so check again.
    */
-   if ( statvfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
+   if ( statfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
       p->errmsg=1;
       context_uninit(p);
       config->emergency="Unable to get available space!";
@@ -1583,6 +1593,31 @@ int proxy(struct proxycontext *p){
    p->usessl=0;
 
    p->server_addr.sin_family = AF_INET;
+
+   int dev;
+   struct pfioc_natlook nl;
+
+   dev = open("/dev/pf", O_RDONLY);
+   if (dev == -1) {
+      do_log(LOG_NOTICE, "open dev pf failed");
+      return -1;
+   }
+  
+   memset(&nl, 0, sizeof(struct pfioc_natlook));
+   nl.saddr.v4.s_addr      = p->client_addr.sin_addr.s_addr;
+   nl.sport                = p->client_addr.sin_port;
+   nl.daddr.v4.s_addr      = read_address("127.0.0.1");
+   nl.dport                = htons(atoi("8110"));
+   nl.af                   = AF_INET;
+   nl.proto                = IPPROTO_TCP;
+   nl.direction            = PF_OUT;
+
+   if (ioctl(dev, DIOCNATLOOK, &nl)) ;
+
+   p->server_addr.sin_addr.s_addr = nl.rdaddr.v4.s_addr;
+   p->server_addr.sin_port = nl.rdport;
+   close(dev);
+
    /*
    // For testing:
    do_log(LOG_DEBUG,"Going to emergency mode...");
@@ -1619,13 +1654,7 @@ int proxy(struct proxycontext *p){
                p->dspamuser=strdup(substr(p->clientbuf->line,5,loc-5));
                p->actsvr=strdup(substr(p->clientbuf->line,loc+1,loc2-loc-1));
                p->actport=atoi(strdup(substr(p->clientbuf->line,loc2+1,len-loc2)));
-               p->server_addr.sin_port=htons(p->actport);
                p->server_host=gethostbyname(p->actsvr);
-               if (p->server_host){
-                  memcpy(&p->server_addr.sin_addr.s_addr, p->server_host->h_addr_list[0], p->server_host->h_length);
-               } else {
-                  p->server_addr.sin_addr.s_addr = inet_addr(p->actsvr);
-               }
                p->clientbuf->linelen=GETLINE_LINE_NULL;
                break;
             } else {
@@ -1638,12 +1667,100 @@ int proxy(struct proxycontext *p){
             }
          }
       }
-   } else {
+   }
+
+   // Init buf at this point, so we can get any SSLproxy info from the client
+   if (!config->useurl) p->clientbuf=linebuf_init(4096);
+
+   // Sending initial OK to get SSLproxy info, if any
+   if (writeline(p->client_fd, WRITELINE_LEADING_RN,POK)){
+      do_log(LOG_CRIT, "ERR: Can't send +OK to client!");
+      return 1;
+   }
+
+   p->sslproxy_addr=NULL;
+   char *saved_line=NULL;
+   while(1){
+	   clientret=getlinep3(p->client_fd, p->clientbuf);
+	   if (clientret==GETLINE_OK){
+			// SSLproxy: [127.0.0.1]:34649,[192.168.3.24]:47286,[74.125.206.108]:465,s
+			if (!strncasecmp(p->clientbuf->line, "SSLproxy:", 9)) {
+				do_log(LOG_DEBUG, p->clientbuf->line);
+
+				char *ip_start = strchr(p->clientbuf->line, '[') + 1;
+				char *ip_end = strchr(ip_start, ']');
+				char *port_start = strchr(ip_end, ':') + 1;
+				char *port_end = strchr(port_start, ',');
+
+				if (!ip_start || !ip_end || !port_start || !port_end) {
+					do_log(LOG_CRIT, "Unable to find sslproxy addr fields: %s", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				int addr_len = ip_end - ip_start;
+				p->sslproxy_addr = malloc(addr_len+1);
+				strncpy(p->sslproxy_addr, ip_start, addr_len);
+				p->sslproxy_addr[addr_len] = '\0';
+
+				int port_len = port_end - port_start;
+				char *port = malloc(port_len + 1);
+				strncpy(port, port_start, port_len);
+				port[port_len] = '\0';
+				p->sslproxy_port=atoi(port);
+				
+				ip_start = strchr(port_end, '[') + 1;
+				ip_end = strchr(ip_start, ']');
+				port_start = strchr(ip_end, ':') + 1;
+				port_end = strchr(port_start, ',');
+
+				if (!ip_start || !ip_end || !port_start || !port_end) {
+					do_log(LOG_CRIT, "Unable to find sslproxy src addr fields: %s", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				addr_len = ip_end - ip_start;
+				p->sslproxy_src_addr = malloc(addr_len + 1);
+				strncpy(p->sslproxy_src_addr, ip_start, addr_len);
+				p->sslproxy_src_addr[addr_len] = '\0';
+
+				port_len = port_end - port_start;
+				p->sslproxy_src_port = malloc(port_len + 1);
+				strncpy(p->sslproxy_src_port, port_start, port_len);
+				p->sslproxy_src_port[port_len] = '\0';
+				
+				ip_start = strchr(port_end, '[') + 1;
+				ip_end = strchr(ip_start, ']');
+				port_start = strchr(ip_end, ':') + 1;
+				port_end = strchr(port_start, ',');
+				char *ssl_start = port_end + 1;
+
+				if (!ip_start || !ip_end || !port_start || !port_end) {
+					do_log(LOG_CRIT, "Unable to find sslproxy dst addr fields: %s", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				addr_len = ip_end - ip_start;
+				p->sslproxy_dst_addr = malloc(addr_len + 1);
+				strncpy(p->sslproxy_dst_addr, ip_start, addr_len);
+				p->sslproxy_dst_addr[addr_len] = '\0';
+
+				port_len = port_end - port_start;
+				p->sslproxy_dst_port = malloc(port_len + 1);
+				strncpy(p->sslproxy_dst_port, port_start, port_len);
+				p->sslproxy_dst_port[port_len] = '\0';
+
+				p->sslproxy_ssl = strchr(ssl_start, 's') ? 1 : 0;
+				break;
+			} else {
+			   do_log(LOG_DEBUG, "client said: %s", p->clientbuf->line);
+			   saved_line = p->clientbuf->line;
+			   break;
+			}
+	   }
+   }
+
+   if (!p->sslproxy_addr) {
       if (htonl(INADDR_ANY) == config->targetaddr.sin_addr.s_addr) {
-         if (getsockopt(p->client_fd, SOL_IP, SO_ORIGINAL_DST, &p->server_addr, &p->socksize)){
-            do_log(LOG_CRIT, "ERR: No IP-Conntrack-data (getsockopt failed)");
-            return 1;
-         }
          /* try to avoid loop */
          if (((ntohl(p->server_addr.sin_addr.s_addr) == INADDR_LOOPBACK)
          && p->server_addr.sin_port == config->addr.sin_port )
@@ -1658,6 +1775,7 @@ int proxy(struct proxycontext *p){
          p->server_addr.sin_port = config->targetaddr.sin_port;
       }
    }
+   
    /* open socket to 'real-server' */
    if ((p->server_fd = socket(PF_INET, SOCK_STREAM, 0)) < 0){
       do_log(LOG_CRIT, "ERR: Cannot open socket to real-server");
@@ -1670,23 +1788,50 @@ int proxy(struct proxycontext *p){
 #endif
    p->serverbuf=linebuf_init(4096);
    p->params=paramlist_init();
-   if (!config->useurl) p->clientbuf=linebuf_init(4096);
+
    /* Check connection type */
    if (ntohs(p->server_addr.sin_port)==config->smtpport){
       p->cksmtp=1;   /* Processing an SMTP message */
       p->checksmtp=1;/* We should scan it */
       do_log(LOG_NOTICE, "SMTP Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
-   } else if(ntohs(p->server_addr.sin_port)==config->sslport){
-      p->usessl=1;
-      do_log(LOG_NOTICE, "POP3S Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
    } else {
-      do_log(LOG_NOTICE, "POP3 Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
+      if (!p->sslproxy_addr) {
+		if(ntohs(p->server_addr.sin_port)==config->sslport){
+		   p->usessl=1;
+		   do_log(LOG_NOTICE, "POP3S Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
+		} else {
+		   do_log(LOG_NOTICE, "POP3 Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
+		}
+	  } else {
+		// We are behind an SSLproxy
+		if(p->sslproxy_ssl){
+		   do_log(LOG_NOTICE, "POP3S Connection from %s:%s", p->sslproxy_src_addr, p->sslproxy_src_port);
+		} else {
+		   do_log(LOG_NOTICE, "POP3 Connection from %s:%s", p->sslproxy_src_addr, p->sslproxy_src_port);
+		}
+	  }
    }
-   do_log(LOG_NOTICE, "Real-server address is %s:%i", inet_ntoa(p->server_addr.sin_addr), ntohs(p->server_addr.sin_port));
+   if (!p->sslproxy_dst_addr) {
+	  do_log(LOG_NOTICE, "Real-server address is %s:%i", inet_ntoa(p->server_addr.sin_addr), ntohs(p->server_addr.sin_port));
+   } else {
+	  do_log(LOG_NOTICE, "Real-server address is %s:%s", p->sslproxy_dst_addr, p->sslproxy_dst_port);
+   }
    if (p->usessl) ret=SSL_create_conn(p->server_fd, (struct sockaddr *) &p->server_addr, p->socksize, &p->ssl, &p->ctx, &p->sbio);
-   else ret=connect(p->server_fd, (struct sockaddr *) &p->server_addr, p->socksize);
+   else {
+	   if (!p->sslproxy_addr) {
+			ret=connect(p->server_fd, (struct sockaddr *) &p->server_addr, p->socksize);
+	   } else {
+			// Since we are behind an SSLproxy, connect to it instead of the real server
+			do_log(LOG_DEBUG, "SSLproxy address is %s:%d", p->sslproxy_addr, p->sslproxy_port);
+			struct  sockaddr_in   sslproxy_addr;
+            sslproxy_addr.sin_family = AF_INET;
+			sslproxy_addr.sin_port=htons(p->sslproxy_port);
+			sslproxy_addr.sin_addr.s_addr = inet_addr(p->sslproxy_addr);
+			ret=connect(p->server_fd, (struct sockaddr *) &sslproxy_addr, p->socksize);
+	   }
+   }
    if(ret) {
-      do_log(LOG_CRIT, "ERR: Cannot connect to real-server: %s",inet_ntoa(p->server_addr.sin_addr));
+      do_log(LOG_CRIT, "ERR: Cannot connect to real-server: %s, %s",inet_ntoa(p->server_addr.sin_addr), strerror(errno));
       return 1;
    }
    set_defaultparams(p);
@@ -1700,7 +1845,13 @@ int proxy(struct proxycontext *p){
    while (1){
 
       /* read from client */
-      clientret=getlinep3(p->client_fd, p->clientbuf);
+	  if (saved_line) {
+		  // We already have a line from the client, consume it first
+		  clientret = GETLINE_OK;
+		  saved_line = NULL;
+	  } else {
+		  clientret = getlinep3(p->client_fd, p->clientbuf);
+	  }
       if (clientret<0){
         if (clientret==GETLINE_TOO_LONG){
           do_log(LOG_DEBUG, "Line too long: Getting rest of line.");
@@ -2800,7 +2951,7 @@ void parseoptions(int argc, char **argv){
                         rest=line+i+ii+1;
                         if (rest && strlen(rest)>0 ){
                            pargv[pargc][strlen(pargv[pargc])]='=';
-                           memcpy(pargv[pargc]+i+1, rest, strlen(rest)+1); //TODO: Source and destination overlap in memcpy
+                           memmove(pargv[pargc]+i+1, rest, strlen(rest)+1); //TODO: Source and destination overlap in memcpy
                         }
                      }
                   }
@@ -2873,7 +3024,7 @@ int main(int argc, char ** argv){
    int connfd=0, i=0, cuid=0;
    int abortfd=0;
    struct sockaddr_in  addr;
-   size_t socksize = sizeof(struct sockaddr_in);
+   socklen_t socksize = sizeof(struct sockaddr_in);
    pid_t pid;
    int stat=0;
    FILE * fp;
@@ -2882,12 +3033,12 @@ int main(int argc, char ** argv){
    char * responsemsg;
    int virusdirlen=0;
    char chownit[100];
-#define CHOWNCMD "/bin/chown"
+#define CHOWNCMD "/usr/sbin/chown"
    int len=0;
    int ret=0;
    FILE * chowncmd;
    unsigned long kbfree;
-   struct statvfs fs;
+   struct statfs fs;
 
    w_memory_init();                  // We need to initialize our memory allocation routines
 
@@ -2931,11 +3082,14 @@ int main(int argc, char ** argv){
       do_log(LOG_NOTICE, "Changing uid (we are root)");
       pws = getpwnam(config->runasuser);
       if (pws == NULL) do_log(LOG_EMERG,"ERR: Unknown User '%s'",config->runasuser);
+      if (setgid(pws->pw_gid) != 0) {
+      	do_log(LOG_ERR,"ERR: Cannot setgid() '%s'",pws->pw_gid);
+      }
       setuid(pws->pw_uid);
    }
    cuid=getuid();
    pws = getpwuid(cuid);
-   do_log(LOG_NOTICE, "Running as user: %s",pws->pw_name);
+   do_log(LOG_NOTICE, "Running as user:gid %s:%d",pws->pw_name,pws->pw_gid);
    if (p3signal(SIGCHLD, do_sigchld)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGCHLD");
    if (p3signal(SIGTERM, do_sigterm_main)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGTERM main");
    if (p3signal(SIGINT, do_sigterm_main)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGINT main");
@@ -3024,7 +3178,7 @@ int main(int argc, char ** argv){
          numprocs++;
          do_log(LOG_DEBUG, "Forked, pid=%i, numprocs=%i", pid, numprocs);
          close (connfd);
-         /* wir brauchen die nicht, der childprocess kümmert sich drum
+         /* wir brauchen die nicht, der childprocess kmmert sich drum
             we don't need "them" (connfd?), child process takes care of that */
          if (numprocs>=config->maxchilds){
             do_log(LOG_WARNING, "MAX_CHILDS (%i) reached!", config->maxchilds);
@@ -3036,7 +3190,7 @@ int main(int argc, char ** argv){
       }else{
          /* child */
          config->child=1;
-         if ( statvfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
+         if ( statfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
             config->emergency="Unable to get available space!";
             do_log(LOG_EMERG, "ERR: Unable to get available space!");
             return SCANNER_RET_CRIT; // Should never reach here, but keep it clean. :)
