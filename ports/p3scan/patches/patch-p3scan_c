$ComixWall: patch-p3scan_c,v 1.6 2016/07/12 10:30:10 soner Exp $
Index: p3scan.c
--- p3scan.c.orig
+++ p3scan.c
@@ -44,33 +44,36 @@ TODO: Wanted: no iptables support
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <sys/socket.h>
+#include <signal.h>
+#include <assert.h>
 #include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include <sys/time.h>
+#include <sys/param.h>
+#include <sys/signal.h>
 #include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <net/pfvar.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <stdarg.h>
-#include <sys/signal.h>
-#include <sys/wait.h>
 #include <pwd.h>
 #include <time.h>
-#include <sys/time.h>
 #include <syslog.h>
-#include <sys/param.h>
 #include <ctype.h>
-#include <linux/netfilter_ipv4.h>
-#include <malloc.h>
 #include <getopt.h>
 #include <netdb.h>
 #include <libgen.h>
 #include <errno.h>
 #include <dirent.h>
-#include <sys/statvfs.h>
-#include <assert.h>
-#include <sys/select.h>
+#include <sys/ucred.h>
+#include <sys/mount.h>
 
 #include "p3scan.h"
 #include "getline_ssl.h"
@@ -85,6 +88,10 @@ TODO: Wanted: no iptables support
 /* globals */
 int numprocs;
 struct configuration_t * config;
+// The global memory allocation list used by the memory management wrappers
+memory_list *memory_list_head;
+// The global couter indicating the number of bytes allocated
+unsigned long global_memory_count;
 
 /* p->ismail legend:
    ismail=0 not processing a message - parsing client commands
@@ -105,6 +112,13 @@ extern int filecount;
 extern int MIMEH_set_outputdir(char *);
 #endif
 
+u_int32_t read_address(const char *s)
+{
+	int a, b, c, d;
+	sscanf(s, "%i.%i.%i.%i", &a, &b, &c, &d);
+	return htonl(a << 24 | b << 16 | c << 8 | d);
+}
+
 static int sockfd; /* has to be global, do_sigterm_main() want's to close them */
 
 /* the proxycontext is global for do_sigterm_proxy().
@@ -152,7 +166,7 @@ void do_log(int level, const char *fmt,...){
    if (!config->debug && config->quiet && level==LOG_NOTICE) return;
    va_start(az,fmt);
    vsnprintf(puffer, 4000, fmt, az);
-   strcpy(timenow,ctime(&now)+ 11);
+   strlcpy(timenow,ctime(&now)+ 11, sizeof(timenow));
    if (!config->debug){
      openlog(config->syslogname, LOGOPT, LOGFAC);
      syslog(LOG_NOTICE, "%s\n", puffer);
@@ -401,7 +415,7 @@ char *right(char *string, size_t i){
 
    if (i > strlength) i = strlength;
    buf = stralloc(i);
-   strcpy(buf, &string[strlength-i]);
+   strlcpy(buf, &string[strlength-i], i);
    return buf;
 }
 
@@ -699,7 +713,7 @@ int scan_mailfile(struct proxycontext *p){
 #define COPYMSG "/var/spool/p3scan/copymsg "
    FILE * scanner;
    static char  line[4096*16];
-   struct statvfs fs;
+   struct statfs fs;
    int htmlfd=0;
 
    ret=checktimeout(p);
@@ -720,7 +734,7 @@ int scan_mailfile(struct proxycontext *p){
    what the user determines is enough room in p3scan.conf
    This was already done... but it is also dynamic so check again.
    */
-   if ( statvfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
+   if ( statfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
       p->errmsg=1;
       context_uninit(p);
       config->emergency="Unable to get available space!";
@@ -1198,7 +1212,7 @@ void set_defaultparams(struct proxycontext * p){
          }
          pclose(scanner);
          if (vlen < 512) virdef[vlen-1]='\0';
-         else virdef[512]='\0';
+         else virdef[511]='\0';
          paramlist_set(p->params, "%VDINFO%", virdef);
       }
    } else paramlist_set(p->params, "%VDINFO%", NULL);
@@ -1575,6 +1589,8 @@ int proxy(struct proxycontext *p){
    int   loc,loc2,first=1;
    char  *tmp=NULL;
    char  *tmp2=NULL;
+   int wait_loop_count=0;
+#define MAX_WAIT_LOOP_COUNT 10
 
    p->now = time(NULL);
    p->header_fd=-1;
@@ -1583,6 +1599,31 @@ int proxy(struct proxycontext *p){
    p->usessl=0;
 
    p->server_addr.sin_family = AF_INET;
+
+   int dev;
+   struct pfioc_natlook nl;
+
+   dev = open("/dev/pf", O_RDONLY);
+   if (dev == -1) {
+      do_log(LOG_NOTICE, "open dev pf failed");
+      return -1;
+   }
+  
+   memset(&nl, 0, sizeof(struct pfioc_natlook));
+   nl.saddr.v4.s_addr      = p->client_addr.sin_addr.s_addr;
+   nl.sport                = p->client_addr.sin_port;
+   nl.daddr.v4.s_addr      = read_address("127.0.0.1");
+   nl.dport                = htons(atoi("8110"));
+   nl.af                   = AF_INET;
+   nl.proto                = IPPROTO_TCP;
+   nl.direction            = PF_OUT;
+
+   if (ioctl(dev, DIOCNATLOOK, &nl)) ;
+
+   p->server_addr.sin_addr.s_addr = nl.rdaddr.v4.s_addr;
+   p->server_addr.sin_port = nl.rdport;
+   close(dev);
+
    /*
    // For testing:
    do_log(LOG_DEBUG,"Going to emergency mode...");
@@ -1595,6 +1636,8 @@ int proxy(struct proxycontext *p){
          do_log(LOG_CRIT, "ERR: Can't send +OK to client!");
          return 1;
       }
+
+      wait_loop_count=0;
       while(1){
          clientret=getlinep3(p->client_fd, p->clientbuf);
          if (clientret==GETLINE_OK){
@@ -1619,13 +1662,7 @@ int proxy(struct proxycontext *p){
                p->dspamuser=strdup(substr(p->clientbuf->line,5,loc-5));
                p->actsvr=strdup(substr(p->clientbuf->line,loc+1,loc2-loc-1));
                p->actport=atoi(strdup(substr(p->clientbuf->line,loc2+1,len-loc2)));
-               p->server_addr.sin_port=htons(p->actport);
                p->server_host=gethostbyname(p->actsvr);
-               if (p->server_host){
-                  memcpy(&p->server_addr.sin_addr.s_addr, p->server_host->h_addr_list[0], p->server_host->h_length);
-               } else {
-                  p->server_addr.sin_addr.s_addr = inet_addr(p->actsvr);
-               }
                p->clientbuf->linelen=GETLINE_LINE_NULL;
                break;
             } else {
@@ -1636,14 +1673,234 @@ int proxy(struct proxycontext *p){
                }
                do_log(LOG_DEBUG,"Told client: -ERR Not Identified");
             }
+         } else {
+            if (++wait_loop_count >= MAX_WAIT_LOOP_COUNT) {
+               do_log(LOG_ERR, "ERR: Timed out waiting client 1");
+               return SCANNER_RET_ERR;
+			}
+            do_log(LOG_DEBUG, "Waiting client 1, count: %d", wait_loop_count);
+            sleep(1);
          }
       }
-   } else {
-      if (htonl(INADDR_ANY) == config->targetaddr.sin_addr.s_addr) {
-         if (getsockopt(p->client_fd, SOL_IP, SO_ORIGINAL_DST, &p->server_addr, &p->socksize)){
-            do_log(LOG_CRIT, "ERR: No IP-Conntrack-data (getsockopt failed)");
-            return 1;
+   }
+
+   // Init buf at this point, so we can get any SSLproxy info from the client
+   if (!config->useurl) p->clientbuf=linebuf_init(4096);
+
+   // Sending initial OK to get SSLproxy line, if any
+   if (writeline(p->client_fd, WRITELINE_LEADING_RN,POK)){
+      do_log(LOG_CRIT, "ERR: Can't send +OK to client!");
+      return 1;
+   }
+
+   int behind_sslproxy = 0;
+   char *saved_line = NULL;
+   wait_loop_count = 0;
+   while(1){
+	   // getlinep3() returns a NULL-terminated string, replacing '\r' and '\n' with '\0'
+	   clientret=getlinep3(p->client_fd, p->clientbuf);
+	   if (clientret==GETLINE_OK){
+			// SSLproxy: [127.0.0.1]:34649,[192.168.3.24]:47286,[74.125.206.108]:465,s,soner
+			if (!strncasecmp(p->clientbuf->line, "SSLproxy:", 9)) {
+				do_log(LOG_DEBUG, p->clientbuf->line);
+
+				// The checks here cannot cover all possible error conditions
+				// But we should at least avoid crashes, for example caused by passing NULL pointers to str*() functions
+				char *ip_start = strchr(p->clientbuf->line, '[');
+				if (!ip_start) {
+					do_log(LOG_ERR, "Unable to find sslproxy ip_start: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+				ip_start++;
+
+				char *ip_end = strchr(ip_start, ']');
+				if (!ip_end) {
+					do_log(LOG_ERR, "Unable to find sslproxy ip_end: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				char *port_start = strchr(ip_end, ':');
+				if (!port_start) {
+					do_log(LOG_ERR, "Unable to find sslproxy port_start: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+				port_start++;
+
+				char *port_end = strchr(port_start, ',');
+				if (!port_end) {
+					do_log(LOG_ERR, "Unable to find sslproxy port_end: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				int addr_len = ip_end - ip_start;
+				if (addr_len > MAX_IPADDR_LEN) {
+					do_log(LOG_ERR, "sslproxy addr_len greater than MAX_IPADDR_LEN: %d\n", addr_len);
+					return SCANNER_RET_ERR;
+				}
+
+				// We can use addr_len for size restriction here, because we check it against MAX_IPADDR_LEN above
+				strncpy(p->sslproxy_addr, ip_start, addr_len);
+				p->sslproxy_addr[addr_len] = '\0';
+
+				int port_len = port_end - port_start;
+				if (port_len > MAX_PORT_LEN) {
+					do_log(LOG_ERR, "sslproxy port_len greater than MAX_PORT_LEN: %d\n", port_len);
+					return SCANNER_RET_ERR;
+				}
+
+				// We can use port_len for size restriction here, because we check it against MAX_PORT_LEN above
+				char port[port_len + 1];
+				strncpy(port, port_start, port_len);
+				port[port_len] = '\0';
+				p->sslproxy_port = atoi(port);
+
+				ip_start = strchr(port_end, '[');
+				if (!ip_start) {
+					do_log(LOG_ERR, "Unable to find sslproxy src ip_start: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+				ip_start++;
+
+				ip_end = strchr(ip_start, ']');
+				if (!ip_end) {
+					do_log(LOG_ERR, "Unable to find sslproxy src ip_end: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				port_start = strchr(ip_end, ':');
+				if (!port_start) {
+					do_log(LOG_ERR, "Unable to find sslproxy src port_start: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+				port_start++;
+
+				port_end = strchr(port_start, ',');
+				if (!port_end) {
+					do_log(LOG_ERR, "Unable to find sslproxy src port_end: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				addr_len = ip_end - ip_start;
+				if (addr_len > MAX_IPADDR_LEN) {
+					do_log(LOG_ERR, "src addr_len greater than MAX_IPADDR_LEN: %d\n", addr_len);
+					return SCANNER_RET_ERR;
+				}
+
+				strncpy(p->sslproxy_src_addr, ip_start, addr_len);
+				p->sslproxy_src_addr[addr_len] = '\0';
+
+				port_len = port_end - port_start;
+				if (port_len > MAX_PORT_LEN) {
+					do_log(LOG_ERR, "src port_len greater than MAX_PORT_LEN: %d\n", port_len);
+					return SCANNER_RET_ERR;
+				}
+
+				strncpy(p->sslproxy_src_port, port_start, port_len);
+				p->sslproxy_src_port[port_len] = '\0';
+
+				ip_start = strchr(port_end, '[');
+				if (!ip_start) {
+					do_log(LOG_ERR, "Unable to find sslproxy dst ip_start: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+				ip_start++;
+
+				ip_end = strchr(ip_start, ']');
+				if (!ip_end) {
+					do_log(LOG_ERR, "Unable to find sslproxy dst ip_end: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				port_start = strchr(ip_end, ':');
+				if (!port_start) {
+					do_log(LOG_ERR, "Unable to find sslproxy dst port_start: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+				port_start++;
+
+				port_end = strchr(port_start, ',');
+				if (!port_end) {
+					do_log(LOG_ERR, "Unable to find sslproxy dst port_end: %s\n", p->clientbuf->line);
+					return SCANNER_RET_ERR;
+				}
+
+				addr_len = ip_end - ip_start;
+				if (addr_len > MAX_IPADDR_LEN) {
+					do_log(LOG_ERR, "dst addr_len greater than MAX_IPADDR_LEN: %d\n", addr_len);
+					return SCANNER_RET_ERR;
+				}
+
+				strncpy(p->sslproxy_dst_addr, ip_start, addr_len);
+				p->sslproxy_dst_addr[addr_len] = '\0';
+
+				port_len = port_end - port_start;
+				if (port_len > MAX_PORT_LEN) {
+					do_log(LOG_ERR, "dst port_len greater than MAX_PORT_LEN: %d\n", port_len);
+					return SCANNER_RET_ERR;
+				}
+
+				strncpy(p->sslproxy_dst_port, port_start, port_len);
+				p->sslproxy_dst_port[port_len] = '\0';
+
+				char *ssl_start = port_end + 1;
+				char *ssl_end = strchr(ssl_start, ',');
+				int ssl_len = 0;
+				if (ssl_end) {
+					// There is user info at the end
+					ssl_len = ssl_end - ssl_start;
+
+					char *user = ssl_end + 1;
+
+					// It is safe to use strlen() here, because getlinep3() trims the \r\n at the end of line
+					int user_len = strlen(user);
+					if (user_len > MAX_USER_LEN) {
+						do_log(LOG_ERR, "user_len greater than MAX_USER_LEN: %d\n", user_len);
+						return SCANNER_RET_ERR;
+					}
+
+					// We can use user_len for size restriction here, because we check it against MAX_USER_LEN above
+					strncpy(p->sslproxy_user, user, user_len);
+					p->sslproxy_user[user_len] = '\0';
+				} else {
+					// It is safe to use strlen() here, because getlinep3() trims the \r\n at the end of line
+					ssl_len = strlen(ssl_start);
+
+					strncpy(p->sslproxy_user, "Unknown", 7);
+					p->sslproxy_user[7] = '\0';
+				}
+
+				if (ssl_len != 1) {
+					do_log(LOG_ERR, "ssl_len not 1: %d\n", ssl_len);
+					return SCANNER_RET_ERR;
+				}
+
+				if (ssl_start[0] != 'p' && ssl_start[0] != 's') {
+					do_log(LOG_ERR, "ssl char not p/s: %c\n", ssl_start[0]);
+					return SCANNER_RET_ERR;
+				}
+
+				p->sslproxy_ssl = ssl_start[0] = 's' ? 1 : 0;
+
+				// Successfully parsed the SSLproxy line, so we are behind an SSLproxy
+				behind_sslproxy = 1;
+				break;
+			} else {
+			   do_log(LOG_DEBUG, "client said: %s", p->clientbuf->line);
+			   saved_line = p->clientbuf->line;
+			   break;
+			}
+         } else {
+            if (++wait_loop_count >= MAX_WAIT_LOOP_COUNT) {
+               do_log(LOG_ERR, "ERR: Timed out waiting client 2");
+               return SCANNER_RET_ERR;
+            }
+            do_log(LOG_DEBUG, "Waiting client 2, count: %d", wait_loop_count);
+            sleep(1);
          }
+   }
+
+   if (!behind_sslproxy) {
+      if (htonl(INADDR_ANY) == config->targetaddr.sin_addr.s_addr) {
          /* try to avoid loop */
          if (((ntohl(p->server_addr.sin_addr.s_addr) == INADDR_LOOPBACK)
          && p->server_addr.sin_port == config->addr.sin_port )
@@ -1658,6 +1915,7 @@ int proxy(struct proxycontext *p){
          p->server_addr.sin_port = config->targetaddr.sin_port;
       }
    }
+   
    /* open socket to 'real-server' */
    if ((p->server_fd = socket(PF_INET, SOCK_STREAM, 0)) < 0){
       do_log(LOG_CRIT, "ERR: Cannot open socket to real-server");
@@ -1670,23 +1928,50 @@ int proxy(struct proxycontext *p){
 #endif
    p->serverbuf=linebuf_init(4096);
    p->params=paramlist_init();
-   if (!config->useurl) p->clientbuf=linebuf_init(4096);
+
    /* Check connection type */
    if (ntohs(p->server_addr.sin_port)==config->smtpport){
       p->cksmtp=1;   /* Processing an SMTP message */
       p->checksmtp=1;/* We should scan it */
       do_log(LOG_NOTICE, "SMTP Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
-   } else if(ntohs(p->server_addr.sin_port)==config->sslport){
-      p->usessl=1;
-      do_log(LOG_NOTICE, "POP3S Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
    } else {
-      do_log(LOG_NOTICE, "POP3 Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
+      if (!behind_sslproxy) {
+		if(ntohs(p->server_addr.sin_port)==config->sslport){
+		   p->usessl=1;
+		   do_log(LOG_NOTICE, "POP3S Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
+		} else {
+		   do_log(LOG_NOTICE, "POP3 Connection from %s:%i", inet_ntoa(p->client_addr.sin_addr), ntohs(p->client_addr.sin_port));
+		}
+	  } else {
+		// We are behind an SSLproxy
+		if(p->sslproxy_ssl){
+		   do_log(LOG_NOTICE, "POP3S Connection from %s:%s spuser %s", p->sslproxy_src_addr, p->sslproxy_src_port, p->sslproxy_user);
+		} else {
+		   do_log(LOG_NOTICE, "POP3 Connection from %s:%s spuser %s", p->sslproxy_src_addr, p->sslproxy_src_port, p->sslproxy_user);
+		}
+	  }
    }
-   do_log(LOG_NOTICE, "Real-server address is %s:%i", inet_ntoa(p->server_addr.sin_addr), ntohs(p->server_addr.sin_port));
+   if (!behind_sslproxy) {
+	  do_log(LOG_NOTICE, "Real-server address is %s:%i", inet_ntoa(p->server_addr.sin_addr), ntohs(p->server_addr.sin_port));
+   } else {
+	  do_log(LOG_NOTICE, "Real-server address is %s:%s", p->sslproxy_dst_addr, p->sslproxy_dst_port);
+   }
    if (p->usessl) ret=SSL_create_conn(p->server_fd, (struct sockaddr *) &p->server_addr, p->socksize, &p->ssl, &p->ctx, &p->sbio);
-   else ret=connect(p->server_fd, (struct sockaddr *) &p->server_addr, p->socksize);
+   else {
+	   if (!behind_sslproxy) {
+			ret=connect(p->server_fd, (struct sockaddr *) &p->server_addr, p->socksize);
+	   } else {
+			// Since we are behind an SSLproxy, connect to it instead of the real server
+			do_log(LOG_DEBUG, "SSLproxy address is %s:%d", p->sslproxy_addr, p->sslproxy_port);
+			struct sockaddr_in sslproxy_addr;
+            sslproxy_addr.sin_family = AF_INET;
+			sslproxy_addr.sin_port=htons(p->sslproxy_port);
+			sslproxy_addr.sin_addr.s_addr = inet_addr(p->sslproxy_addr);
+			ret=connect(p->server_fd, (struct sockaddr *) &sslproxy_addr, p->socksize);
+	   }
+   }
    if(ret) {
-      do_log(LOG_CRIT, "ERR: Cannot connect to real-server: %s",inet_ntoa(p->server_addr.sin_addr));
+      do_log(LOG_CRIT, "ERR: Cannot connect to real-server: %s, %s",inet_ntoa(p->server_addr.sin_addr), strerror(errno));
       return 1;
    }
    set_defaultparams(p);
@@ -1700,7 +1985,13 @@ int proxy(struct proxycontext *p){
    while (1){
 
       /* read from client */
-      clientret=getlinep3(p->client_fd, p->clientbuf);
+	  if (saved_line != NULL) {
+		  // We already have a line from the client, consume it first
+		  clientret = GETLINE_OK;
+		  saved_line = NULL;
+	  } else {
+		  clientret = getlinep3(p->client_fd, p->clientbuf);
+	  }
       if (clientret<0){
         if (clientret==GETLINE_TOO_LONG){
           do_log(LOG_DEBUG, "Line too long: Getting rest of line.");
@@ -2093,13 +2384,13 @@ int proxy(struct proxycontext *p){
                      paramlist_set(p->params, "%MAILFILE%", p->mailfile);
                      if (config->delit) paramlist_set(p->params, "%P3SCANID%", config->notify);
                      else paramlist_set(p->params, "%P3SCANID%", p->filename);
-                     do_log(LOG_WARNING, "%s from %s:%s to %s:%s from %s to %s user: %s virus: %s file: %s",
+                     do_log(LOG_WARNING, "%s from %s:%s to %s:%s from %s to %s user: %s virus: %s file: %s spuser: %s",
                         paramlist_get(p->params,"%PROTOCOL%"),
                         paramlist_get(p->params,"%CLIENTIP%"), paramlist_get(p->params,"%CLIENTPORT%"),
                         paramlist_get(p->params,"%SERVERIP%"), paramlist_get(p->params,"%SERVERPORT%"),
                         paramlist_get(p->params,"%MAILFROM%"), paramlist_get(p->params,"%MAILTO%"),
                         paramlist_get(p->params,"%USERNAME%"), paramlist_get(p->params,"%VIRUSNAME%"),
-                        paramlist_get(p->params,"%P3SCANID%")
+                        paramlist_get(p->params,"%P3SCANID%"), p->sslproxy_user
                      );
                      if (do_virusaction(p)!=0){
                         if (p->cksmtp) {
@@ -2332,402 +2623,407 @@ void usage(char * progname){
    "\n"
    );
 }
+
+struct option long_options[] = {
+	{ "renattach",    required_argument,   NULL, 'a' },
+	{ "altvnmsg",     no_argument,         NULL, 'A' },
+	{ "bytesfree",    required_argument,   NULL, 'b' },
+	{ "broken",       no_argument,         NULL, 'B' },
+	{ "viruscode",    required_argument,   NULL, 'c' },
+	{ "checksize",    required_argument,   NULL, 'C' },
+	{ "debug",        no_argument,         NULL, 'd' },
+	{ "extra",        required_argument,   NULL, 'e' },
+	{ "emailport",    required_argument,   NULL, 'E' },
+	{ "configfile",   required_argument,   NULL, 'f' },
+	{ "footer",       required_argument,   NULL, 'F' },
+	{ "virusregexp",  required_argument,   NULL, 'g' },
+	{ "goodcode",     required_argument,   NULL, 'G' },
+	{ "help",         no_argument,         NULL, 'h' },
+	{ "ip",           required_argument,   NULL, 'i' },
+	{ "targetip",     required_argument,   NULL, 'I' },
+	{ "justdelete",   no_argument,         NULL, 'j' },
+	{ "enabletop",    no_argument,         NULL, 'J' },
+	{ "checkspam",    no_argument,         NULL, 'k' },
+	{ "emergcon",     required_argument,   NULL, 'K' },
+	{ "pidfile",      required_argument,   NULL, 'l' },
+	{ "sslport",      required_argument,   NULL, 'L' },
+	{ "maxchilds",    required_argument,   NULL, 'm' },
+	{ "ispspam",      required_argument,   NULL, 'M' },
+	{ "notifydir",    required_argument,   NULL, 'n' },
+	{ "notify",       required_argument,   NULL, 'N' },
+	{ "overwrite",    required_argument,   NULL, 'o' },
+	{ "timeout",      required_argument,   NULL, 'O' },
+	{ "port",         required_argument,   NULL, 'p' },
+	{ "targetport",   required_argument,   NULL, 'P' },
+	{ "quiet",        no_argument,         NULL, 'q' },
+	{ "virusdir",     required_argument,   NULL, 'r' },
+	{ "smtprset",     required_argument,   NULL, 'R' },
+	{ "scanner",      required_argument,   NULL, 's' },
+	{ "subject",      required_argument,   NULL, 'S' },
+	{ "template",     required_argument,   NULL, 't' },
+	{ "scannertype",  required_argument,   NULL, 'T' },
+	{ "user",         required_argument,   NULL, 'u' },
+	{ "useurl",       no_argument,         NULL, 'U' },
+	{ "version",      no_argument,         NULL, 'v' },
+#ifdef DEMIME
+	{ "demime",       no_argument,         NULL, 'x' },
+#endif
+	{ "xmail",        required_argument,   NULL, 'X' },
+	{ "spamcheck",    required_argument,   NULL, 'z' },
+	{ NULL,           no_argument,         NULL, 0 }
+};
+
+long parseargs(int c, char **argv, char *where, int state, char *getoptparam, char **rest, long i, long *ii, int *error){
+  int option, option_index = 0;
+  struct servent *port;
+  int pidfd;
+
+  opterr=0;
+  optind=1;
+  while (1){
+     option = getopt_long(c, argv, getoptparam, long_options, &option_index);
+     if (option == EOF) break;
+		char *next_tok;
+		switch (option){
+		   case 'h':
+		   case 'v':
+		   case 'f':
+			  /* don't check in second run (is in the first) */
+			  if (state==CONFIG_STATE_CMD)
+				  return i;
+			  /* disallow help/version/configfile in configfile */
+			  if (state==CONFIG_STATE_FILE){
+				 fprintf(stderr, "%s '%s' is not allowed in configfile!\n", where, argv[optind-1]);
+				 *error=1;
+				 return i;
+			  }
+		   break;
+		   default:
+		   /* only check help/version/configfile for the first cmd run */
+		   if (state==CONFIG_STATE_CMDPRE)
+			   return i;
+		}
+
+		switch (option){
+		   case 'h': /* usage */
+			  usage(argv[0]);
+			  exit(0);
+			  break;
+		   case 'v': /* version */
+			  printversion();
+			  exit(0);
+			  break;
+		   case 'f': /* config (file) */
+			  config->configfile = optarg;
+			  break;
+		   case 'F': /* footer (file) */
+			  config->footer = optarg;
+			  break;
+		   case 'd': /* debug */
+			  config->debug=1;
+			  break;
+		   case 'e': /* Extra notification */
+			  config->extra=optarg;
+			  break;
+		   case 'E': /* SMTP (email) port */
+			  i=strtol(optarg, rest, 10);
+			  if (*rest && strlen(*rest)>0){
+				 if (i>0){ /* 123abc */
+					fprintf(stderr, "%s %s isn't a valid port\n", where, optarg);
+					*error=1;
+				 }else{
+					if((port=getservbyname(optarg, "tcp"))!=NULL) config->smtpport=ntohs(port->s_port);
+					else{
+					   fprintf(stderr, "Port lookup for '%s/tcp' failed! Check /etc/services\n", optarg);
+					   *error=1;
+					 }
+				  }
+			  } else {
+				  if (i>0) config->smtpport=i;
+				  else {
+					fprintf(stderr, "%s Incorrect emailport portnumber\n", where);
+					*error=1;
+				  }
+			  }
+			  break;
+		   case 'l': /* PID File */
+			  config->pidfile=optarg;
+			  if ((pidfd=open(config->pidfile,O_RDONLY ))>=0){
+				 do_log(LOG_EMERG, "ERR: PID file %s exists! Aborting!",config->pidfile);
+				 /* Should not reach here. We are dead. */
+				 pidfd=close(pidfd);
+				 exit(0);
+			  }
+			  break;
+		   case 'L': /* SSL port */
+			  i=strtol(optarg, rest, 10);
+			  if (*rest && strlen(*rest)>0){
+				 if (i>0){ /* 123abc */
+					fprintf(stderr, "%s %s isn't a valid port\n", where, optarg);
+					*error=1;
+				 }else{
+					if((port=getservbyname(optarg, "tcp"))!=NULL) config->sslport=ntohs(port->s_port);
+					else{
+					   fprintf(stderr, "Port lookup for '%s/tcp' failed! Check /etc/services\n", optarg);
+					   *error=1;
+					}
+				 }
+			  } else {
+				 if (i>0) config->sslport=i;
+				 else {
+					fprintf(stderr, "%s Incorrect POP3S portnumber\n", where);
+					*error=1;
+				 }
+			  }
+			  break;
+		   case 'a': /* rename attachments using renattach */
+			  config->renattach=optarg;
+			  break;
+		   case 'A': /* use alternate virus notification email */
+			  config->altemail=1;
+			  break;
+		   case 'r': /* virusdir */
+			  config->virusdirbase=optarg;
+			  config->virusdir=config->virusdirbase;
+			  break;
+		   case 'R': /* smtp reject */
+			  config->smtprset=optarg;
+			  break;
+		   case 'n': /* notifydir */
+			  config->notifydir=optarg;
+			  break;
+		   case 'm': /* Max Childs */
+			  i=strtol(optarg, rest, 10);
+			  if ((*rest && strlen(*rest)>0) || i<1 || i>9999){
+				 fprintf(stderr, "%s --maxchilds has to be 1 < val < 10000\n", where);
+				 *error=1;
+			  } else config->maxchilds=(int)i;
+			  break;
+		   case 'i': /* IP (to listen on) */
+			  if (!strcmp(optarg, "0.0.0.0")){
+				 config->addr.sin_addr.s_addr=htonl(INADDR_ANY);
+			  }else if (!inet_aton(optarg, &config->addr.sin_addr)){
+				 fprintf(stderr, "%s %s isn't a valid IP Adress\n", where, optarg);
+				 *error=1;
+			  }
+			  break;
+		   case 'I': /* IP (to connect) */
+			  if (!strcmp(optarg, "0.0.0.0")){
+				 config->targetaddr.sin_addr.s_addr=htonl(INADDR_ANY);
+			  }else if (!inet_aton(optarg, &config->targetaddr.sin_addr)){
+				 fprintf(stderr, "%s %s isn't a valid IP Adress\n", where, optarg);
+				 *error=1;
+			  }
+			  break;
+		   case 'o': /* overwrite (disable) HTML */
+			  config->overwrite=optarg;
+			  break;
+		   case 'O': /* timeOut */
+			  i=strtol(optarg, rest, 10);
+			  if ((*rest && strlen(*rest)>0) || i<1 || i>9999){
+				 fprintf(stderr, "%s --timeout has to be 1 < val < 10000\n", where);
+				 *error=1;
+			  } else config->timeout=(int)i;
+			  break;
+		   case 'p': /* Port */
+			  i=strtol(optarg, rest, 10);
+			  if (*rest && strlen(*rest)>0){
+				 if (i>0){ /* 123abc */
+					fprintf(stderr, "%s %s isn't a valid port\n", where, optarg);
+					*error=1;
+				 }else{
+					if((port=getservbyname(optarg, "tcp"))!=NULL){
+					   config->addr.sin_port=port->s_port;
+					}else{
+					   fprintf(stderr, "Port lookup for '%s/tcp' failed! Check /etc/services\n", optarg);
+					   *error=1;
+					}
+				 }
+			  }else{
+				 if (i>0)config->addr.sin_port=htons((int)i);
+				 else{
+					fprintf(stderr, "%s Incorrect POP3 portnumber\n", where);
+					*error=1;
+				 }
+			  }
+			  break;
+		   case 'P': /* target Port */
+			  i=strtol(optarg, rest, 10);
+			  if (*rest && strlen(*rest)>0){
+				 if (i>0){ /* 123abc */
+					fprintf(stderr, "%s %s isn't a valid port\n", where, optarg);
+					*error=1;
+				 }else{
+					if((port=getservbyname(optarg, "tcp"))!=NULL){
+					   config->targetaddr.sin_port=port->s_port;
+					}else{
+					   fprintf(stderr, "Port lookup for '%s/tcp' failed! Check /etc/services\n", optarg);
+					   *error=1;
+					}
+				 }
+			  }else{
+				 if (i>0)config->targetaddr.sin_port=htons((int)i);
+				 else{
+					fprintf(stderr, "%s Incorrect target portnumber\n", where);
+					*error=1;
+				 }
+			  }
+			  break;
+		   case 'q': /* quiet */
+			  config->quiet=1;
+			  break;
+		   case 'u': /* Run as User */
+			  config->runasuser=optarg;
+			  /* getpwnam will also accept UID's, so we need no converting*/
+			  break;
+		   case 'U': /* Parse username for destination url */
+			  config->useurl=1;
+			  break;
+		   case 's': /* Scanner */
+			  config->virusscanner=optarg;
+			  break;
+		   case 't': /* template */
+			  config->virustemplate=optarg;
+			  break;
+		   case 'c': /* Virus (exit) code */
+			  *ii = 0;
+			  next_tok = strtok(optarg, " \t,");
+			  if (next_tok){
+				 do{
+					if (*ii < MAX_VIRUS_CODES){
+					   i=strtol(next_tok, rest, 10);
+					   if ( (*rest && strlen(*rest)>0) || i<1 || i>256){
+						  fprintf(stderr, "%s --viruscode has be a list of numbers (%s)\n", where, *rest);
+						  *error=1;
+					   }else config->viruscode[*ii]=(int)i;
+					   *ii++;
+					}
+				 }while ((next_tok = strtok(NULL, " \t,")) || (*ii >= MAX_VIRUS_CODES));
+			  }
+			  config->viruscode[*ii] = -1;
+			  if (*ii == 0){
+				 fprintf(stderr, "%s --viruscode has be a list of numbers (%s)\n", where, *rest);
+				 *error=1;
+			  }
+			  break;
+		   case 'G': /* Good Virus (exit) code */
+			  *ii = 0;
+			  next_tok = strtok(optarg, " \t,");
+			  if (next_tok){
+				 do{
+					if (*ii < MAX_VIRUS_CODES){
+					   i=strtol(next_tok, rest, 10);
+					   if ( (*rest && strlen(*rest)>0) || i<1 || i>256){
+						  fprintf(stderr, "%s --good viruscode has be a list of numbers (%s)\n", where, *rest);
+						  *error=1;
+					   }else config->gvcode[*ii]=(int)i;
+					   *ii++;
+					}
+				 }while ((next_tok = strtok(NULL, " \t,")) || (*ii >= MAX_VIRUS_CODES));
+			  }
+			  config->gvcode[*ii] = -1;
+			  if (*ii == 0){
+				 fprintf(stderr, "%s --good viruscode has be a list of numbers (%s)\n", where, *rest);
+				 *error=1;
+			  }
+			  break;
+	  #ifdef DEMIME
+		   case 'x': /* demime */
+			  config->demime = 1;
+			  break;
+	  #endif
+		   case 'X': /* Xtra notification reciept mail program */
+			  config->mail=optarg;
+			  break;
+		   case 'T': /* scannertype */
+			  i=0;
+			  while (scannerlist[i]){
+				 if(!strcasecmp(optarg, scannerlist[i]->name)){
+					config->scanner=scannerlist[i];
+					i=-1;
+					break;
+				 }
+				 i++;
+			  }
+			  if (i!=-1){
+				 fprintf(stderr, "%s scannertype '%s' is not supported", where, optarg);
+				 *error=1;
+			  }
+			  break;
+		   case 'g': /* virusregexp */
+			  config->virusregexp = optarg;
+			  i=strlen(optarg);
+			  if (optarg[i-2]=='/' && isdigit(optarg[i-1])){
+				 optarg[i-2]='\0';
+				 config->virusregexpsub=optarg[i-1]-'0';
+			  }
+			  break;
+		   case 'k': /* check for spam */
+			  config->checkspam=1;
+			  break;
+		   case 'K': /* emergency Kontact! */
+			  config->emergcon = optarg;
+			  break;
+		   case 'z': /* path to spam checking executable */
+			  config->spamcheck = optarg;
+			  break;
+		   case 'b': /* bytes free */
+			  i=strtol(optarg, rest, 10);
+			  config->freespace=(int)i;
+			  break;
+		   case 'C': /* Check SMTP size */
+			  i=strtol(optarg, rest, 10);
+			  config->smtpsize=(int)i;
+			  break;
+		   case 'j': /* justdelete */
+			  config->delit=1;
+			  break;
+		   case 'J': /* enabletop */
+			  config->enabletop=1;
+			  break;
+		   case 'B': /* broken */
+			  config->broken=1;
+			  break;
+		   case 'S': /* Subject line for virus notification */
+			  config->subject = optarg;
+			  break;
+		   case 'N': /* deleted file notification */
+			  config->notify = optarg;
+			  break;
+		   case 'M': /* ISP marked as SPAM */
+			  config->ispspam = optarg;
+			  break;
+
+		   default:
+			  fprintf(stderr, "%s Option '%s' isn't known\n", where, getoptparam);
+			  *error=1;
+		}
+  }
+  if (state != CONFIG_STATE_CMDPRE && optind < c){
+     *error=1;
+     while (optind < c) fprintf(stderr, "%s Unknown option '%s'\n", where, argv[optind++]);
+  }
+  return i;
+}
+
 void parseoptions(int argc, char **argv){
-   long i, ii;
-   char * rest;
+   long i = 0;
+   long ii = 0;
+   char *rest;
    int error = 0;
-   struct servent *port;
    int fp, res;
    struct linebuf *cf;
    char *pargv[MAX_PSEUDO_ARGV];
    int pargc;
    char *line;
-   int pidfd;
    int dofree=0;
 
-   struct option long_options[] = {
-   { "renattach",    required_argument,   NULL, 'a' },
-   { "altvnmsg",     no_argument,         NULL, 'A' },
-   { "bytesfree",    required_argument,   NULL, 'b' },
-   { "broken",       no_argument,         NULL, 'B' },
-   { "viruscode",    required_argument,   NULL, 'c' },
-   { "checksize",    required_argument,   NULL, 'C' },
-   { "debug",        no_argument,         NULL, 'd' },
-   { "extra",        required_argument,   NULL, 'e' },
-   { "emailport",    required_argument,   NULL, 'E' },
-   { "configfile",   required_argument,   NULL, 'f' },
-   { "footer",       required_argument,   NULL, 'F' },
-   { "virusregexp",  required_argument,   NULL, 'g' },
-   { "goodcode",     required_argument,   NULL, 'G' },
-   { "help",         no_argument,         NULL, 'h' },
-   { "ip",           required_argument,   NULL, 'i' },
-   { "targetip",     required_argument,   NULL, 'I' },
-   { "justdelete",   no_argument,         NULL, 'j' },
-   { "enabletop",    no_argument,         NULL, 'J' },
-   { "checkspam",    no_argument,         NULL, 'k' },
-   { "emergcon",     required_argument,   NULL, 'K' },
-   { "pidfile",      required_argument,   NULL, 'l' },
-   { "sslport",      required_argument,   NULL, 'L' },
-   { "maxchilds",    required_argument,   NULL, 'm' },
-   { "ispspam",      required_argument,   NULL, 'M' },
-   { "notifydir",    required_argument,   NULL, 'n' },
-   { "notify",       required_argument,   NULL, 'N' },
-   { "overwrite",    required_argument,   NULL, 'o' },
-   { "timeout",      required_argument,   NULL, 'O' },
-   { "port",         required_argument,   NULL, 'p' },
-   { "targetport",   required_argument,   NULL, 'P' },
-   { "quiet",        no_argument,         NULL, 'q' },
-   { "virusdir",     required_argument,   NULL, 'r' },
-   { "smtprset",     required_argument,   NULL, 'R' },
-   { "scanner",      required_argument,   NULL, 's' },
-   { "subject",      required_argument,   NULL, 'S' },
-   { "template",     required_argument,   NULL, 't' },
-   { "scannertype",  required_argument,   NULL, 'T' },
-   { "user",         required_argument,   NULL, 'u' },
-   { "useurl",       no_argument,         NULL, 'U' },
-   { "version",      no_argument,         NULL, 'v' },
 #ifdef DEMIME
-   { "demime",       no_argument,         NULL, 'x' },
-#endif
-   { "xmail",        required_argument,   NULL, 'X' },
-   { "spamcheck",    required_argument,   NULL, 'z' },
-   { NULL,           no_argument,         NULL, 0 }
-   };
-#ifdef DEMIME
    char getoptparam[] = "hvf:a:Ab:Bc:C:de:F:g:G:i:I:jJkK:l:L:m:M:n:N:o:O:p:P:qr:R:s:S:t:T:u:UxX:z:";
 #else
    char getoptparam[] = "hvf:a:Ab:Bc:C:de:F:g:G:i:I:jJkK:l:L:m:M:n:N:o:O:p:P:qr:R:s:S:t:T:u:UX:z:";
 #endif
-   void switchoption(char opt, char * arg, char * optstr, char * where, int state){
-      char *next_tok;
-      switch (opt){
-         case 'h':
-         case 'v':
-         case 'f':
-            /* don't check in second run (is in the first) */
-            if (state==CONFIG_STATE_CMD) return;
-            /* disallow help/version/configfile in configfile */
-            if (state==CONFIG_STATE_FILE){
-               fprintf(stderr, "%s '%s' is not allowed in configfile!\n", where, optstr);
-               error=1;
-               return;
-            }
-         break;
-         default:
-         /* only check help/version/configfile for the first cmd run */
-         if (state==CONFIG_STATE_CMDPRE) return;
-      }
 
-      switch (opt){
-         case 'h': /* usage */
-            usage(argv[0]);
-            exit(0);
-            break;
-         case 'v': /* version */
-            printversion();
-            exit(0);
-            break;
-         case 'f': /* config (file) */
-            config->configfile = arg;
-            break;
-         case 'F': /* footer (file) */
-            config->footer = arg;
-            break;
-         case 'd': /* debug */
-            config->debug=1;
-            break;
-         case 'e': /* Extra notification */
-            config->extra=arg;
-            break;
-         case 'E': /* SMTP (email) port */
-            i=strtol(arg, &rest, 10);
-            if (rest && strlen(rest)>0){
-               if (i>0){ /* 123abc */
-                  fprintf(stderr, "%s %s isn't a valid port\n", where, arg);
-                  error=1;
-               }else{
-                  if((port=getservbyname(arg, "tcp"))!=NULL) config->smtpport=ntohs(port->s_port);
-                  else{
-                     fprintf(stderr, "Port lookup for '%s/tcp' failed! Check /etc/services\n", arg);
-                     error=1;
-                   }
-                }
-            } else {
-                if (i>0) config->smtpport=i;
-                else {
-                  fprintf(stderr, "%s Incorrect emailport portnumber\n", where);
-                  error=1;
-                }
-            }
-            break;
-         case 'l': /* PID File */
-            config->pidfile=arg;
-            if ((pidfd=open(config->pidfile,O_RDONLY ))>=0){
-               do_log(LOG_EMERG, "ERR: PID file %s exists! Aborting!",config->pidfile);
-               /* Should not reach here. We are dead. */
-               pidfd=close(pidfd);
-               exit(0);
-            }
-            break;
-         case 'L': /* SSL port */
-            i=strtol(arg, &rest, 10);
-            if (rest && strlen(rest)>0){
-               if (i>0){ /* 123abc */
-                  fprintf(stderr, "%s %s isn't a valid port\n", where, arg);
-                  error=1;
-               }else{
-                  if((port=getservbyname(arg, "tcp"))!=NULL) config->sslport=ntohs(port->s_port);
-                  else{
-                     fprintf(stderr, "Port lookup for '%s/tcp' failed! Check /etc/services\n", arg);
-                     error=1;
-                  }
-               }
-            } else {
-               if (i>0) config->sslport=i;
-               else {
-                  fprintf(stderr, "%s Incorrect POP3S portnumber\n", where);
-                  error=1;
-               }
-            }
-            break;
-         case 'a': /* rename attachments using renattach */
-            config->renattach=arg;
-            break;
-         case 'A': /* use alternate virus notification email */
-            config->altemail=1;
-            break;
-         case 'r': /* virusdir */
-            config->virusdirbase=arg;
-            config->virusdir=config->virusdirbase;
-            break;
-         case 'R': /* smtp reject */
-            config->smtprset=arg;
-            break;
-         case 'n': /* notifydir */
-            config->notifydir=arg;
-            break;
-         case 'm': /* Max Childs */
-            i=strtol(arg, &rest, 10);
-            if ((rest && strlen(rest)>0) || i<1 || i>9999){
-               fprintf(stderr, "%s --maxchilds has to be 1 < val < 10000\n", where);
-               error=1;
-            } else config->maxchilds=(int)i;
-            break;
-         case 'i': /* IP (to listen on) */
-            if (!strcmp(arg, "0.0.0.0")){
-               config->addr.sin_addr.s_addr=htonl(INADDR_ANY);
-            }else if (!inet_aton(arg, &config->addr.sin_addr)){
-               fprintf(stderr, "%s %s isn't a valid IP Adress\n", where, arg);
-               error=1;
-            }
-            break;
-         case 'I': /* IP (to connect) */
-            if (!strcmp(arg, "0.0.0.0")){
-               config->targetaddr.sin_addr.s_addr=htonl(INADDR_ANY);
-            }else if (!inet_aton(arg, &config->targetaddr.sin_addr)){
-               fprintf(stderr, "%s %s isn't a valid IP Adress\n", where, arg);
-               error=1;
-            }
-            break;
-         case 'o': /* overwrite (disable) HTML */
-            config->overwrite=arg;
-            break;
-         case 'O': /* timeOut */
-            i=strtol(arg, &rest, 10);
-            if ((rest && strlen(rest)>0) || i<1 || i>9999){
-               fprintf(stderr, "%s --timeout has to be 1 < val < 10000\n", where);
-               error=1;
-            } else config->timeout=(int)i;
-            break;
-         case 'p': /* Port */
-            i=strtol(arg, &rest, 10);
-            if (rest && strlen(rest)>0){
-               if (i>0){ /* 123abc */
-                  fprintf(stderr, "%s %s isn't a valid port\n", where, arg);
-                  error=1;
-               }else{
-                  if((port=getservbyname(arg, "tcp"))!=NULL){
-                     config->addr.sin_port=port->s_port;
-                  }else{
-                     fprintf(stderr, "Port lookup for '%s/tcp' failed! Check /etc/services\n", arg);
-                     error=1;
-                  }
-               }
-            }else{
-               if (i>0)config->addr.sin_port=htons((int)i);
-               else{
-                  fprintf(stderr, "%s Incorrect POP3 portnumber\n", where);
-                  error=1;
-               }
-            }
-            break;
-         case 'P': /* target Port */
-            i=strtol(arg, &rest, 10);
-            if (rest && strlen(rest)>0){
-               if (i>0){ /* 123abc */
-                  fprintf(stderr, "%s %s isn't a valid port\n", where, arg);
-                  error=1;
-               }else{
-                  if((port=getservbyname(arg, "tcp"))!=NULL){
-                     config->targetaddr.sin_port=port->s_port;
-                  }else{
-                     fprintf(stderr, "Port lookup for '%s/tcp' failed! Check /etc/services\n", arg);
-                     error=1;
-                  }
-               }
-            }else{
-               if (i>0)config->targetaddr.sin_port=htons((int)i);
-               else{
-                  fprintf(stderr, "%s Incorrect target portnumber\n", where);
-                  error=1;
-               }
-            }
-            break;
-         case 'q': /* quiet */
-            config->quiet=1;
-            break;
-         case 'u': /* Run as User */
-            config->runasuser=arg;
-            /* getpwnam will also accept UID's, so we need no converting*/
-            break;
-         case 'U': /* Parse username for destination url */
-            config->useurl=1;
-            break;
-         case 's': /* Scanner */
-            config->virusscanner=arg;
-            break;
-         case 't': /* template */
-            config->virustemplate=arg;
-            break;
-         case 'c': /* Virus (exit) code */
-            ii = 0;
-            next_tok = strtok(arg, " \t,");
-            if (next_tok){
-               do{
-                  if (ii < MAX_VIRUS_CODES){
-                     i=strtol(next_tok, &rest, 10);
-                     if ( (rest && strlen(rest)>0) || i<1 || i>256){
-                        fprintf(stderr, "%s --viruscode has be a list of numbers (%s)\n", where, rest);
-                        error=1;
-                     }else config->viruscode[ii]=(int)i;
-                     ii++;
-                  }
-               }while ((next_tok = strtok(NULL, " \t,")) || (ii >= MAX_VIRUS_CODES));
-            }
-            config->viruscode[ii] = -1;
-            if (ii == 0){
-               fprintf(stderr, "%s --viruscode has be a list of numbers (%s)\n", where, rest);
-               error=1;
-            }
-            break;
-         case 'G': /* Good Virus (exit) code */
-            ii = 0;
-            next_tok = strtok(arg, " \t,");
-            if (next_tok){
-               do{
-                  if (ii < MAX_VIRUS_CODES){
-                     i=strtol(next_tok, &rest, 10);
-                     if ( (rest && strlen(rest)>0) || i<1 || i>256){
-                        fprintf(stderr, "%s --good viruscode has be a list of numbers (%s)\n", where, rest);
-                        error=1;
-                     }else config->gvcode[ii]=(int)i;
-                     ii++;
-                  }
-               }while ((next_tok = strtok(NULL, " \t,")) || (ii >= MAX_VIRUS_CODES));
-            }
-            config->gvcode[ii] = -1;
-            if (ii == 0){
-               fprintf(stderr, "%s --good viruscode has be a list of numbers (%s)\n", where, rest);
-               error=1;
-            }
-            break;
-#ifdef DEMIME
-         case 'x': /* demime */
-            config->demime = 1;
-            break;
-#endif
-         case 'X': /* Xtra notification reciept mail program */
-            config->mail=arg;
-            break;
-         case 'T': /* scannertype */
-            i=0;
-            while (scannerlist[i]){
-               if(!strcasecmp(arg, scannerlist[i]->name)){
-                  config->scanner=scannerlist[i];
-                  i=-1;
-                  break;
-               }
-               i++;
-            }
-            if (i!=-1){
-               fprintf(stderr, "%s scannertype '%s' is not supported", where, arg);
-               error=1;
-            }
-            break;
-         case 'g': /* virusregexp */
-            config->virusregexp = arg;
-            i=strlen(arg);
-            if (arg[i-2]=='/' && isdigit(arg[i-1])){
-               arg[i-2]='\0';
-               config->virusregexpsub=arg[i-1]-'0';
-            }
-            break;
-         case 'k': /* check for spam */
-            config->checkspam=1;
-            break;
-         case 'K': /* emergency Kontact! */
-            config->emergcon = arg;
-            break;
-         case 'z': /* path to spam checking executable */
-            config->spamcheck = arg;
-            break;
-         case 'b': /* bytes free */
-            i=strtol(arg, &rest, 10);
-            config->freespace=(int)i;
-            break;
-         case 'C': /* Check SMTP size */
-            i=strtol(arg, &rest, 10);
-            config->smtpsize=(int)i;
-            break;
-         case 'j': /* justdelete */
-            config->delit=1;
-            break;
-         case 'J': /* enabletop */
-            config->enabletop=1;
-            break;
-         case 'B': /* broken */
-            config->broken=1;
-            break;
-         case 'S': /* Subject line for virus notification */
-            config->subject = arg;
-            break;
-         case 'N': /* deleted file notification */
-            config->notify = arg;
-            break;
-         case 'M': /* ISP marked as SPAM */
-            config->ispspam = arg;
-            break;
-
-         default:
-            fprintf(stderr, "%s Option '%s' isn't known\n", where, optstr);
-            error=1;
-      }
-   }/* sub function switchoption  }}} */
-   void parseargs(int c, char **v, char * where, int state){
-      int option, option_index = 0;
-      opterr=0;
-      optind=1;
-      while (1){
-         option = getopt_long(c, v, getoptparam,
-         long_options, &option_index);
-         if (option == EOF) break;
-         switchoption(option, optarg, v[optind-1], where, state);
-      }
-      if (state != CONFIG_STATE_CMDPRE && optind < c){
-         error=1;
-         while (optind < c) fprintf(stderr, "%s Unknown option '%s'\n", where, v[optind++]);
-      }
-   }
    config=w_malloc(sizeof(struct configuration_t));
    /* set defaults for in, char* to NULL */
    config->debug=DEBUG;
@@ -2772,7 +3068,7 @@ void parseoptions(int argc, char **argv){
    config->emergcon=NULL;
    config->emergency=NULL;
    /* parse line args, but for the first time only configfile/version/help */
-   parseargs(argc, argv, "\t[cmdlineparm]", CONFIG_STATE_CMDPRE);
+   i = parseargs(argc, argv, "\t[cmdlineparm]", CONFIG_STATE_CMDPRE, getoptparam, &rest, i, &ii, &error);
    /* parse configfile */
    if (!config->configfile){
       config->configfile=strdup(CONFIGFILE); //TODO: 24 bytes in 1 blocks are definitely lost in loss record 2 of 2
@@ -2800,7 +3096,7 @@ void parseoptions(int argc, char **argv){
                         rest=line+i+ii+1;
                         if (rest && strlen(rest)>0 ){
                            pargv[pargc][strlen(pargv[pargc])]='=';
-                           memcpy(pargv[pargc]+i+1, rest, strlen(rest)+1); //TODO: Source and destination overlap in memcpy
+                           memmove(pargv[pargc]+i+1, rest, strlen(rest)+1); //TODO: Source and destination overlap in memcpy
                         }
                      }
                   }
@@ -2812,11 +3108,11 @@ void parseoptions(int argc, char **argv){
       close(fp);
       linebuf_uninit(cf);
       pargv[pargc]=NULL;
-      parseargs(pargc, pargv, "\t[configfile]", CONFIG_STATE_FILE);
+      i = parseargs(pargc, pargv, "\t[configfile]", CONFIG_STATE_FILE, getoptparam, &rest, i, &ii, &error);
    }
    if(dofree) free(config->configfile);
    /* now check the rest of commandline args (higher precedence than configfile) */
-   parseargs(argc, argv, "\t[cmdlineparm]", CONFIG_STATE_CMD);
+   i = parseargs(argc, argv, "\t[cmdlineparm]", CONFIG_STATE_CMD, getoptparam, &rest, i, &ii, &error);
    if (error){
       printf(
       "Commandline options/configfile are not ok\n"
@@ -2873,7 +3169,7 @@ int main(int argc, char ** argv){
    int connfd=0, i=0, cuid=0;
    int abortfd=0;
    struct sockaddr_in  addr;
-   size_t socksize = sizeof(struct sockaddr_in);
+   socklen_t socksize = sizeof(struct sockaddr_in);
    pid_t pid;
    int stat=0;
    FILE * fp;
@@ -2882,12 +3178,12 @@ int main(int argc, char ** argv){
    char * responsemsg;
    int virusdirlen=0;
    char chownit[100];
-#define CHOWNCMD "/bin/chown"
+#define CHOWNCMD "/usr/sbin/chown"
    int len=0;
    int ret=0;
    FILE * chowncmd;
    unsigned long kbfree;
-   struct statvfs fs;
+   struct statfs fs;
 
    w_memory_init();                  // We need to initialize our memory allocation routines
 
@@ -2931,11 +3227,14 @@ int main(int argc, char ** argv){
       do_log(LOG_NOTICE, "Changing uid (we are root)");
       pws = getpwnam(config->runasuser);
       if (pws == NULL) do_log(LOG_EMERG,"ERR: Unknown User '%s'",config->runasuser);
+      if (setgid(pws->pw_gid) != 0) {
+      	do_log(LOG_ERR,"ERR: Cannot setgid() '%s'",pws->pw_gid);
+      }
       setuid(pws->pw_uid);
    }
    cuid=getuid();
    pws = getpwuid(cuid);
-   do_log(LOG_NOTICE, "Running as user: %s",pws->pw_name);
+   do_log(LOG_NOTICE, "Running as user:gid %s:%d",pws->pw_name,pws->pw_gid);
    if (p3signal(SIGCHLD, do_sigchld)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGCHLD");
    if (p3signal(SIGTERM, do_sigterm_main)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGTERM main");
    if (p3signal(SIGINT, do_sigterm_main)<0) do_log(LOG_EMERG, "ERR: Could not set signal handler SIGINT main");
@@ -3024,7 +3323,7 @@ int main(int argc, char ** argv){
          numprocs++;
          do_log(LOG_DEBUG, "Forked, pid=%i, numprocs=%i", pid, numprocs);
          close (connfd);
-         /* wir brauchen die nicht, der childprocess kmmert sich drum
+         /* wir brauchen die nicht, der childprocess kmmert sich drum
             we don't need "them" (connfd?), child process takes care of that */
          if (numprocs>=config->maxchilds){
             do_log(LOG_WARNING, "MAX_CHILDS (%i) reached!", config->maxchilds);
@@ -3036,7 +3335,7 @@ int main(int argc, char ** argv){
       }else{
          /* child */
          config->child=1;
-         if ( statvfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
+         if ( statfs( config->virusdir, &fs ) == SCANNER_RET_ERR){
             config->emergency="Unable to get available space!";
             do_log(LOG_EMERG, "ERR: Unable to get available space!");
             return SCANNER_RET_CRIT; // Should never reach here, but keep it clean. :)
@@ -3107,3 +3406,4 @@ int main(int argc, char ** argv){
    do_sigterm_main(-1);
    return 0;
 }
+
